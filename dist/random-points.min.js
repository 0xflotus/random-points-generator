!(function(r, e) {
  'object' == typeof exports && 'object' == typeof module
    ? (module.exports = e())
    : 'function' == typeof define && define.amd
      ? define([], e)
      : 'object' == typeof exports
        ? (exports.geotools = e())
        : (r.geotools = e());
})(window, function() {
  return (function(r) {
    var e = {};
    function t(n) {
      if (e[n]) return e[n].exports;
      var o = (e[n] = { i: n, l: !1, exports: {} });
      return r[n].call(o.exports, o, o.exports, t), (o.l = !0), o.exports;
    }
    return (
      (t.m = r),
      (t.c = e),
      (t.d = function(r, e, n) {
        t.o(r, e) ||
          Object.defineProperty(r, e, {
            configurable: !1,
            enumerable: !0,
            get: n,
          });
      }),
      (t.r = function(r) {
        Object.defineProperty(r, '__esModule', { value: !0 });
      }),
      (t.n = function(r) {
        var e =
          r && r.__esModule
            ? function() {
                return r.default;
              }
            : function() {
                return r;
              };
        return t.d(e, 'a', e), e;
      }),
      (t.o = function(r, e) {
        return Object.prototype.hasOwnProperty.call(r, e);
      }),
      (t.p = ''),
      t((t.s = 10))
    );
  })([
    function(r, e, t) {
      'use strict';
      function n(r, e, t) {
        if (!i((t = t || {}))) throw new Error('options is invalid');
        var n = t.bbox,
          o = t.id;
        if (void 0 === r) throw new Error('geometry is required');
        if (e && e.constructor !== Object)
          throw new Error('properties must be an Object');
        n && a(n), o && s(o);
        var u = { type: 'Feature' };
        return (
          o && (u.id = o),
          n && (u.bbox = n),
          (u.properties = e || {}),
          (u.geometry = r),
          u
        );
      }
      function o(r) {
        return !isNaN(r) && null !== r && !Array.isArray(r);
      }
      function i(r) {
        return !!r && r.constructor === Object;
      }
      function a(r) {
        if (!r) throw new Error('bbox is required');
        if (!Array.isArray(r)) throw new Error('bbox must be an Array');
        if (4 !== r.length && 6 !== r.length)
          throw new Error('bbox must be an Array of 4 or 6 numbers');
        r.forEach(function(r) {
          if (!o(r)) throw new Error('bbox must only contain numbers');
        });
      }
      function s(r) {
        if (!r) throw new Error('id is required');
        if (-1 === ['string', 'number'].indexOf(typeof r))
          throw new Error('id must be a number or a string');
      }
      function u(r, e, t) {
        if (null !== r)
          for (
            var n,
              o,
              i,
              a,
              s,
              f,
              h,
              c,
              l = 0,
              d = 0,
              g = r.type,
              m = 'FeatureCollection' === g,
              p = 'Feature' === g,
              b = m ? r.features.length : 1,
              w = 0;
            w < b;
            w++
          ) {
            s = (c =
              !!(h = m ? r.features[w].geometry : p ? r.geometry : r) &&
              'GeometryCollection' === h.type)
              ? h.geometries.length
              : 1;
            for (var v = 0; v < s; v++) {
              var y = 0,
                x = 0;
              if (null !== (a = c ? h.geometries[v] : h)) {
                f = a.coordinates;
                var E = a.type;
                switch (
                  ((l =
                    !t || ('Polygon' !== E && 'MultiPolygon' !== E) ? 0 : 1),
                  E)
                ) {
                  case null:
                    break;
                  case 'Point':
                    if (!1 === e(f, d, w, y, x)) return !1;
                    d++, y++;
                    break;
                  case 'LineString':
                  case 'MultiPoint':
                    for (n = 0; n < f.length; n++) {
                      if (!1 === e(f[n], d, w, y, x)) return !1;
                      d++, 'MultiPoint' === E && y++;
                    }
                    'LineString' === E && y++;
                    break;
                  case 'Polygon':
                  case 'MultiLineString':
                    for (n = 0; n < f.length; n++) {
                      for (o = 0; o < f[n].length - l; o++) {
                        if (!1 === e(f[n][o], d, w, y, x)) return !1;
                        d++;
                      }
                      'MultiLineString' === E && y++, 'Polygon' === E && x++;
                    }
                    'Polygon' === E && y++;
                    break;
                  case 'MultiPolygon':
                    for (n = 0; n < f.length; n++) {
                      for (
                        'MultiPolygon' === E && (x = 0), o = 0;
                        o < f[n].length;
                        o++
                      ) {
                        for (i = 0; i < f[n][o].length - l; i++) {
                          if (!1 === e(f[n][o][i], d, w, y, x)) return !1;
                          d++;
                        }
                        x++;
                      }
                      y++;
                    }
                    break;
                  case 'GeometryCollection':
                    for (n = 0; n < a.geometries.length; n++)
                      if (!1 === u(a.geometries[n], e, t)) return !1;
                    break;
                  default:
                    throw new Error('Unknown Geometry Type');
                }
              }
            }
          }
      }
      function f(r, e) {
        if ('Feature' === r.type) e(r, 0);
        else if ('FeatureCollection' === r.type)
          for (
            var t = 0;
            t < r.features.length && !1 !== e(r.features[t], t);
            t++
          );
      }
      function h(r, e) {
        var t,
          n,
          o,
          i,
          a,
          s,
          u,
          f,
          h,
          c,
          l = 0,
          d = 'FeatureCollection' === r.type,
          g = 'Feature' === r.type,
          m = d ? r.features.length : 1;
        for (t = 0; t < m; t++) {
          for (
            s = d ? r.features[t].geometry : g ? r.geometry : r,
              f = d ? r.features[t].properties : g ? r.properties : {},
              h = d ? r.features[t].bbox : g ? r.bbox : void 0,
              c = d ? r.features[t].id : g ? r.id : void 0,
              a = (u = !!s && 'GeometryCollection' === s.type)
                ? s.geometries.length
                : 1,
              o = 0;
            o < a;
            o++
          )
            if (null !== (i = u ? s.geometries[o] : s))
              switch (i.type) {
                case 'Point':
                case 'LineString':
                case 'MultiPoint':
                case 'Polygon':
                case 'MultiLineString':
                case 'MultiPolygon':
                  if (!1 === e(i, l, f, h, c)) return !1;
                  break;
                case 'GeometryCollection':
                  for (n = 0; n < i.geometries.length; n++)
                    if (!1 === e(i.geometries[n], l, f, h, c)) return !1;
                  break;
                default:
                  throw new Error('Unknown Geometry Type');
              }
            else if (!1 === e(null, l, f, h, c)) return !1;
          l++;
        }
      }
      function c(r, e, t) {
        var n = t;
        return (
          h(r, function(r, o, i, a, s) {
            n = 0 === o && void 0 === t ? r : e(n, r, o, i, a, s);
          }),
          n
        );
      }
      function l(r, e) {
        h(r, function(r, t, o, i, a) {
          var s,
            u = null === r ? null : r.type;
          switch (u) {
            case null:
            case 'Point':
            case 'LineString':
            case 'Polygon':
              return !1 !== e(n(r, o, { bbox: i, id: a }), t, 0) && void 0;
          }
          switch (u) {
            case 'MultiPoint':
              s = 'Point';
              break;
            case 'MultiLineString':
              s = 'LineString';
              break;
            case 'MultiPolygon':
              s = 'Polygon';
          }
          for (var f = 0; f < r.coordinates.length; f++) {
            var h = r.coordinates[f];
            if (!1 === e(n({ type: s, coordinates: h }, o), t, f)) return !1;
          }
        });
      }
      t.d(e, 'a', function() {
        return u;
      }),
        t.d(e, 'b', function() {
          return f;
        }),
        t.d(e, 'd', function() {
          return h;
        }),
        t.d(e, 'e', function() {
          return c;
        }),
        t.d(e, 'c', function() {
          return l;
        });
    },
    function(r, e, t) {
      'use strict';
      function n(r, e, t) {
        var n = !1;
        e[0][0] === e[e.length - 1][0] &&
          e[0][1] === e[e.length - 1][1] &&
          (e = e.slice(0, e.length - 1));
        for (var o = 0, i = e.length - 1; o < e.length; i = o++) {
          var a = e[o][0],
            s = e[o][1],
            u = e[i][0],
            f = e[i][1];
          if (
            r[1] * (a - u) + s * (u - r[0]) + f * (r[0] - a) == 0 &&
            (a - r[0]) * (u - r[0]) <= 0 &&
            (s - r[1]) * (f - r[1]) <= 0
          )
            return !t;
          s > r[1] != f > r[1] &&
            r[0] < (u - a) * (r[1] - s) / (f - s) + a &&
            (n = !n);
        }
        return n;
      }
      e.a = function(r, e, t) {
        if ('object' != typeof (t = t || {}))
          throw new Error('options is invalid');
        var o = t.ignoreBoundary;
        if (!r) throw new Error('point is required');
        if (!e) throw new Error('polygon is required');
        var i = (function(r) {
            if (!r) throw new Error('coord is required');
            if (
              'Feature' === r.type &&
              null !== r.geometry &&
              'Point' === r.geometry.type
            )
              return r.geometry.coordinates;
            if ('Point' === r.type) return r.coordinates;
            if (
              Array.isArray(r) &&
              r.length >= 2 &&
              void 0 === r[0].length &&
              void 0 === r[1].length
            )
              return r;
            throw new Error(
              'coord must be GeoJSON Point or an Array of numbers'
            );
          })(r),
          a = (function(r) {
            if (!r) throw new Error('coords is required');
            if ('Feature' === r.type && null !== r.geometry)
              return r.geometry.coordinates;
            if (r.coordinates) return r.coordinates;
            if (Array.isArray(r)) return r;
            throw new Error(
              'coords must be GeoJSON Feature, Geometry Object or an Array'
            );
          })(e),
          s = e.geometry ? e.geometry.type : e.type,
          u = e.bbox;
        if (
          u &&
          !1 ===
            (function(r, e) {
              return (
                e[0] <= r[0] && e[1] <= r[1] && e[2] >= r[0] && e[3] >= r[1]
              );
            })(i, u)
        )
          return !1;
        'Polygon' === s && (a = [a]);
        for (var f = 0, h = !1; f < a.length && !h; f++)
          if (n(i, a[f][0], o)) {
            for (var c = !1, l = 1; l < a[f].length && !c; )
              n(i, a[f][l], !o) && (c = !0), l++;
            c || (h = !0);
          }
        return h;
      };
    },
    function(r, e, t) {
      'use strict';
      (r.exports = o), (r.exports.default = o);
      var n = t(8);
      function o(r, e) {
        if (!(this instanceof o)) return new o(r, e);
        (this._maxEntries = Math.max(4, r || 9)),
          (this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries))),
          e && this._initFormat(e),
          this.clear();
      }
      function i(r, e, t) {
        if (!t) return e.indexOf(r);
        for (var n = 0; n < e.length; n++) if (t(r, e[n])) return n;
        return -1;
      }
      function a(r, e) {
        s(r, 0, r.children.length, e, r);
      }
      function s(r, e, t, n, o) {
        o || (o = m(null)),
          (o.minX = 1 / 0),
          (o.minY = 1 / 0),
          (o.maxX = -1 / 0),
          (o.maxY = -1 / 0);
        for (var i, a = e; a < t; a++)
          (i = r.children[a]), u(o, r.leaf ? n(i) : i);
        return o;
      }
      function u(r, e) {
        return (
          (r.minX = Math.min(r.minX, e.minX)),
          (r.minY = Math.min(r.minY, e.minY)),
          (r.maxX = Math.max(r.maxX, e.maxX)),
          (r.maxY = Math.max(r.maxY, e.maxY)),
          r
        );
      }
      function f(r, e) {
        return r.minX - e.minX;
      }
      function h(r, e) {
        return r.minY - e.minY;
      }
      function c(r) {
        return (r.maxX - r.minX) * (r.maxY - r.minY);
      }
      function l(r) {
        return r.maxX - r.minX + (r.maxY - r.minY);
      }
      function d(r, e) {
        return (
          r.minX <= e.minX &&
          r.minY <= e.minY &&
          e.maxX <= r.maxX &&
          e.maxY <= r.maxY
        );
      }
      function g(r, e) {
        return (
          e.minX <= r.maxX &&
          e.minY <= r.maxY &&
          e.maxX >= r.minX &&
          e.maxY >= r.minY
        );
      }
      function m(r) {
        return {
          children: r,
          height: 1,
          leaf: !0,
          minX: 1 / 0,
          minY: 1 / 0,
          maxX: -1 / 0,
          maxY: -1 / 0,
        };
      }
      function p(r, e, t, o, i) {
        for (var a, s = [e, t]; s.length; )
          (t = s.pop()) - (e = s.pop()) <= o ||
            ((a = e + Math.ceil((t - e) / o / 2) * o),
            n(r, a, e, t, i),
            s.push(e, a, a, t));
      }
      o.prototype = {
        all: function() {
          return this._all(this.data, []);
        },
        search: function(r) {
          var e = this.data,
            t = [],
            n = this.toBBox;
          if (!g(r, e)) return t;
          for (var o, i, a, s, u = []; e; ) {
            for (o = 0, i = e.children.length; o < i; o++)
              (a = e.children[o]),
                g(r, (s = e.leaf ? n(a) : a)) &&
                  (e.leaf ? t.push(a) : d(r, s) ? this._all(a, t) : u.push(a));
            e = u.pop();
          }
          return t;
        },
        collides: function(r) {
          var e = this.data,
            t = this.toBBox;
          if (!g(r, e)) return !1;
          for (var n, o, i, a, s = []; e; ) {
            for (n = 0, o = e.children.length; n < o; n++)
              if (((i = e.children[n]), g(r, (a = e.leaf ? t(i) : i)))) {
                if (e.leaf || d(r, a)) return !0;
                s.push(i);
              }
            e = s.pop();
          }
          return !1;
        },
        load: function(r) {
          if (!r || !r.length) return this;
          if (r.length < this._minEntries) {
            for (var e = 0, t = r.length; e < t; e++) this.insert(r[e]);
            return this;
          }
          var n = this._build(r.slice(), 0, r.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === n.height) this._splitRoot(this.data, n);
            else {
              if (this.data.height < n.height) {
                var o = this.data;
                (this.data = n), (n = o);
              }
              this._insert(n, this.data.height - n.height - 1, !0);
            }
          else this.data = n;
          return this;
        },
        insert: function(r) {
          return r && this._insert(r, this.data.height - 1), this;
        },
        clear: function() {
          return (this.data = m([])), this;
        },
        remove: function(r, e) {
          if (!r) return this;
          for (
            var t, n, o, a, s = this.data, u = this.toBBox(r), f = [], h = [];
            s || f.length;

          ) {
            if (
              (s ||
                ((s = f.pop()), (n = f[f.length - 1]), (t = h.pop()), (a = !0)),
              s.leaf && -1 !== (o = i(r, s.children, e)))
            )
              return (
                s.children.splice(o, 1), f.push(s), this._condense(f), this
              );
            a || s.leaf || !d(s, u)
              ? n
                ? (t++, (s = n.children[t]), (a = !1))
                : (s = null)
              : (f.push(s), h.push(t), (t = 0), (n = s), (s = s.children[0]));
          }
          return this;
        },
        toBBox: function(r) {
          return r;
        },
        compareMinX: f,
        compareMinY: h,
        toJSON: function() {
          return this.data;
        },
        fromJSON: function(r) {
          return (this.data = r), this;
        },
        _all: function(r, e) {
          for (var t = []; r; )
            r.leaf ? e.push.apply(e, r.children) : t.push.apply(t, r.children),
              (r = t.pop());
          return e;
        },
        _build: function(r, e, t, n) {
          var o,
            i = t - e + 1,
            s = this._maxEntries;
          if (i <= s) return a((o = m(r.slice(e, t + 1))), this.toBBox), o;
          n ||
            ((n = Math.ceil(Math.log(i) / Math.log(s))),
            (s = Math.ceil(i / Math.pow(s, n - 1)))),
            ((o = m([])).leaf = !1),
            (o.height = n);
          var u,
            f,
            h,
            c,
            l = Math.ceil(i / s),
            d = l * Math.ceil(Math.sqrt(s));
          for (p(r, e, t, d, this.compareMinX), u = e; u <= t; u += d)
            for (
              p(r, u, (h = Math.min(u + d - 1, t)), l, this.compareMinY), f = u;
              f <= h;
              f += l
            )
              (c = Math.min(f + l - 1, h)),
                o.children.push(this._build(r, f, c, n - 1));
          return a(o, this.toBBox), o;
        },
        _chooseSubtree: function(r, e, t, n) {
          for (
            var o, i, a, s, u, f, h, l, d, g;
            n.push(e), !e.leaf && n.length - 1 !== t;

          ) {
            for (h = l = 1 / 0, o = 0, i = e.children.length; o < i; o++)
              (u = c((a = e.children[o]))),
                (d = r),
                (g = a),
                (f =
                  (Math.max(g.maxX, d.maxX) - Math.min(g.minX, d.minX)) *
                    (Math.max(g.maxY, d.maxY) - Math.min(g.minY, d.minY)) -
                  u) < l
                  ? ((l = f), (h = u < h ? u : h), (s = a))
                  : f === l && u < h && ((h = u), (s = a));
            e = s || e.children[0];
          }
          return e;
        },
        _insert: function(r, e, t) {
          var n = this.toBBox,
            o = t ? r : n(r),
            i = [],
            a = this._chooseSubtree(o, this.data, e, i);
          for (
            a.children.push(r), u(a, o);
            e >= 0 && i[e].children.length > this._maxEntries;

          )
            this._split(i, e), e--;
          this._adjustParentBBoxes(o, i, e);
        },
        _split: function(r, e) {
          var t = r[e],
            n = t.children.length,
            o = this._minEntries;
          this._chooseSplitAxis(t, o, n);
          var i = this._chooseSplitIndex(t, o, n),
            s = m(t.children.splice(i, t.children.length - i));
          (s.height = t.height),
            (s.leaf = t.leaf),
            a(t, this.toBBox),
            a(s, this.toBBox),
            e ? r[e - 1].children.push(s) : this._splitRoot(t, s);
        },
        _splitRoot: function(r, e) {
          (this.data = m([r, e])),
            (this.data.height = r.height + 1),
            (this.data.leaf = !1),
            a(this.data, this.toBBox);
        },
        _chooseSplitIndex: function(r, e, t) {
          var n, o, i, a, u, f, h, l, d, g, m, p, b, w;
          for (f = h = 1 / 0, n = e; n <= t - e; n++)
            (o = s(r, 0, n, this.toBBox)),
              (i = s(r, n, t, this.toBBox)),
              (d = o),
              (g = i),
              void 0,
              void 0,
              void 0,
              void 0,
              (m = Math.max(d.minX, g.minX)),
              (p = Math.max(d.minY, g.minY)),
              (b = Math.min(d.maxX, g.maxX)),
              (w = Math.min(d.maxY, g.maxY)),
              (a = Math.max(0, b - m) * Math.max(0, w - p)),
              (u = c(o) + c(i)),
              a < f
                ? ((f = a), (l = n), (h = u < h ? u : h))
                : a === f && u < h && ((h = u), (l = n));
          return l;
        },
        _chooseSplitAxis: function(r, e, t) {
          var n = r.leaf ? this.compareMinX : f,
            o = r.leaf ? this.compareMinY : h;
          this._allDistMargin(r, e, t, n) < this._allDistMargin(r, e, t, o) &&
            r.children.sort(n);
        },
        _allDistMargin: function(r, e, t, n) {
          r.children.sort(n);
          var o,
            i,
            a = this.toBBox,
            f = s(r, 0, e, a),
            h = s(r, t - e, t, a),
            c = l(f) + l(h);
          for (o = e; o < t - e; o++)
            (i = r.children[o]), u(f, r.leaf ? a(i) : i), (c += l(f));
          for (o = t - e - 1; o >= e; o--)
            (i = r.children[o]), u(h, r.leaf ? a(i) : i), (c += l(h));
          return c;
        },
        _adjustParentBBoxes: function(r, e, t) {
          for (var n = t; n >= 0; n--) u(e[n], r);
        },
        _condense: function(r) {
          for (var e, t = r.length - 1; t >= 0; t--)
            0 === r[t].children.length
              ? t > 0
                ? (e = r[t - 1].children).splice(e.indexOf(r[t]), 1)
                : this.clear()
              : a(r[t], this.toBBox);
        },
        _initFormat: function(r) {
          var e = ['return a', ' - b', ';'];
          (this.compareMinX = new Function('a', 'b', e.join(r[0]))),
            (this.compareMinY = new Function('a', 'b', e.join(r[1]))),
            (this.toBBox = new Function(
              'a',
              'return {minX: a' +
                r[0] +
                ', minY: a' +
                r[1] +
                ', maxX: a' +
                r[2] +
                ', maxY: a' +
                r[3] +
                '};'
            ));
        },
      };
    },
    function(r, e, t) {
      'use strict';
      t.r(e);
      function n(r, e, t) {
        if (!f((t = t || {}))) throw new Error('options is invalid');
        var n = t.bbox,
          o = t.id;
        if (void 0 === r) throw new Error('geometry is required');
        if (e && e.constructor !== Object)
          throw new Error('properties must be an Object');
        n && h(n), o && c(o);
        var i = { type: 'Feature' };
        return (
          o && (i.id = o),
          n && (i.bbox = n),
          (i.properties = e || {}),
          (i.geometry = r),
          i
        );
      }
      function o(r, e, t) {
        if (!r) throw new Error('coordinates is required');
        if (!Array.isArray(r)) throw new Error('coordinates must be an Array');
        if (r.length < 2)
          throw new Error('coordinates must be at least 2 numbers long');
        if (!u(r[0]) || !u(r[1]))
          throw new Error('coordinates must contain numbers');
        return n({ type: 'Point', coordinates: r }, e, t);
      }
      function i(r, e, t) {
        if (!r) throw new Error('coordinates is required');
        for (var o = 0; o < r.length; o++) {
          var i = r[o];
          if (i.length < 4)
            throw new Error(
              'Each LinearRing of a Polygon must have 4 or more Positions.'
            );
          for (var a = 0; a < i[i.length - 1].length; a++) {
            if ((0 === o && 0 === a && !u(i[0][0])) || !u(i[0][1]))
              throw new Error('coordinates must contain numbers');
            if (i[i.length - 1][a] !== i[0][a])
              throw new Error('First and last Position are not equivalent.');
          }
        }
        return n({ type: 'Polygon', coordinates: r }, e, t);
      }
      function a(r, e, t) {
        if (!r) throw new Error('coordinates is required');
        if (r.length < 2)
          throw new Error(
            'coordinates must be an array of two or more positions'
          );
        if (!u(r[0][1]) || !u(r[0][1]))
          throw new Error('coordinates must contain numbers');
        return n({ type: 'LineString', coordinates: r }, e, t);
      }
      function s(r, e) {
        if (!f((e = e || {}))) throw new Error('options is invalid');
        var t = e.bbox,
          n = e.id;
        if (!r) throw new Error('No features passed');
        if (!Array.isArray(r)) throw new Error('features must be an Array');
        t && h(t), n && c(n);
        var o = { type: 'FeatureCollection' };
        return n && (o.id = n), t && (o.bbox = t), (o.features = r), o;
      }
      function u(r) {
        return !isNaN(r) && null !== r && !Array.isArray(r);
      }
      function f(r) {
        return !!r && r.constructor === Object;
      }
      function h(r) {
        if (!r) throw new Error('bbox is required');
        if (!Array.isArray(r)) throw new Error('bbox must be an Array');
        if (4 !== r.length && 6 !== r.length)
          throw new Error('bbox must be an Array of 4 or 6 numbers');
        r.forEach(function(r) {
          if (!u(r)) throw new Error('bbox must only contain numbers');
        });
      }
      function c(r) {
        if (!r) throw new Error('id is required');
        if (-1 === ['string', 'number'].indexOf(typeof r))
          throw new Error('id must be a number or a string');
      }
      function l(r) {
        if ((f(r) && (r = r.bbox), r && !Array.isArray(r)))
          throw new Error('bbox is invalid');
        return r
          ? (function(r) {
              return [
                Math.random() * (r[2] - r[0]) + r[0],
                Math.random() * (r[3] - r[1]) + r[1],
              ];
            })(r)
          : [360 * b(), 180 * b()];
      }
      function d(r, e) {
        if (!f((e = e || {}))) throw new Error('options is invalid');
        var t = e.bbox;
        (void 0 !== r && null !== r) || (r = 1);
        for (var n = [], i = 0; i < r; i++) n.push(o(l(t)));
        return s(n);
      }
      function g(r, e) {
        if (!f((e = e || {}))) throw new Error('options is invalid');
        var t = e.bbox,
          n = e.num_vertices,
          o = e.max_radial_length;
        (void 0 !== r && null !== r) || (r = 1),
          u(n) || (n = 10),
          u(o) || (o = 10);
        for (var a = [], h = 0; h < r; h++) {
          var c = [],
            d = Array.apply(null, new Array(n + 1)).map(Math.random);
          d.forEach(g),
            d.forEach(m),
            (c[c.length - 1] = c[0]),
            (c = c.map(p(l(t)))),
            a.push(i([c]));
        }
        function g(r, e, t) {
          t[e] = e > 0 ? r + t[e - 1] : r;
        }
        function m(r) {
          r = 2 * r * Math.PI / d[d.length - 1];
          var e = Math.random();
          c.push([e * o * Math.sin(r), e * o * Math.cos(r)]);
        }
        return s(a);
      }
      function m(r, e) {
        if (!f((e = e || {}))) throw new Error('options is invalid');
        var t = e.bbox,
          n = e.num_vertices,
          o = e.max_length,
          i = e.max_rotation;
        (void 0 !== r && null !== r) || (r = 1),
          (!u(n) || n < 2) && (n = 10),
          u(o) || (o = 1e-4),
          u(i) || (i = Math.PI / 8);
        for (var h = [], c = 0; c < r; c++) {
          for (var d = [l(t)], g = 0; g < n - 1; g++) {
            var m =
                (0 === g
                  ? 2 * Math.random() * Math.PI
                  : Math.tan(
                      (d[g][1] - d[g - 1][1]) / (d[g][0] - d[g - 1][0])
                    )) +
                (Math.random() - 0.5) * i * 2,
              p = Math.random() * o;
            d.push([d[g][0] + p * Math.cos(m), d[g][1] + p * Math.sin(m)]);
          }
          h.push(a(d));
        }
        return s(h);
      }
      function p(r) {
        return function(e) {
          return [e[0] + r[0], e[1] + r[1]];
        };
      }
      function b() {
        return Math.random() - 0.5;
      }
      t.d(e, 'randomPosition', function() {
        return l;
      }),
        t.d(e, 'randomPoint', function() {
          return d;
        }),
        t.d(e, 'randomPolygon', function() {
          return g;
        }),
        t.d(e, 'randomLineString', function() {
          return m;
        });
    },
    function(r, e, t) {
      'use strict';
      t.r(e);
      var n = t(1);
      function o(r, e) {
        if (!a((e = e || {}))) throw new Error('options is invalid');
        var t = e.bbox,
          n = e.id;
        if (!r) throw new Error('No features passed');
        if (!Array.isArray(r)) throw new Error('features must be an Array');
        t && s(t), n && u(n);
        var o = { type: 'FeatureCollection' };
        return n && (o.id = n), t && (o.bbox = t), (o.features = r), o;
      }
      function i(r) {
        return !isNaN(r) && null !== r && !Array.isArray(r);
      }
      function a(r) {
        return !!r && r.constructor === Object;
      }
      function s(r) {
        if (!r) throw new Error('bbox is required');
        if (!Array.isArray(r)) throw new Error('bbox must be an Array');
        if (4 !== r.length && 6 !== r.length)
          throw new Error('bbox must be an Array of 4 or 6 numbers');
        r.forEach(function(r) {
          if (!i(r)) throw new Error('bbox must only contain numbers');
        });
      }
      function u(r) {
        if (!r) throw new Error('id is required');
        if (-1 === ['string', 'number'].indexOf(typeof r))
          throw new Error('id must be a number or a string');
      }
      var f = t(0);
      e.default = function(r, e) {
        var t = [];
        return (
          Object(f.d)(e, function(e) {
            Object(f.b)(r, function(r) {
              Object(n.a)(r, e) && t.push(r);
            });
          }),
          o(t)
        );
      };
    },
    function(r, e, t) {
      'use strict';
      t.r(e);
      var n = t(0);
      function o(r, e, t) {
        if (!u((t = t || {}))) throw new Error('options is invalid');
        var n = t.bbox,
          o = t.id;
        if (void 0 === r) throw new Error('geometry is required');
        if (e && e.constructor !== Object)
          throw new Error('properties must be an Object');
        n && f(n), o && h(o);
        var i = { type: 'Feature' };
        return (
          o && (i.id = o),
          n && (i.bbox = n),
          (i.properties = e || {}),
          (i.geometry = r),
          i
        );
      }
      function i(r, e, t) {
        if (!r) throw new Error('coordinates is required');
        for (var n = 0; n < r.length; n++) {
          var i = r[n];
          if (i.length < 4)
            throw new Error(
              'Each LinearRing of a Polygon must have 4 or more Positions.'
            );
          for (var a = 0; a < i[i.length - 1].length; a++) {
            if ((0 === n && 0 === a && !s(i[0][0])) || !s(i[0][1]))
              throw new Error('coordinates must contain numbers');
            if (i[i.length - 1][a] !== i[0][a])
              throw new Error('First and last Position are not equivalent.');
          }
        }
        return o({ type: 'Polygon', coordinates: r }, e, t);
      }
      function a(r, e) {
        if (!u((e = e || {}))) throw new Error('options is invalid');
        var t = e.bbox,
          n = e.id;
        if (!r) throw new Error('No features passed');
        if (!Array.isArray(r)) throw new Error('features must be an Array');
        t && f(t), n && h(n);
        var o = { type: 'FeatureCollection' };
        return n && (o.id = n), t && (o.bbox = t), (o.features = r), o;
      }
      function s(r) {
        return !isNaN(r) && null !== r && !Array.isArray(r);
      }
      function u(r) {
        return !!r && r.constructor === Object;
      }
      function f(r) {
        if (!r) throw new Error('bbox is required');
        if (!Array.isArray(r)) throw new Error('bbox must be an Array');
        if (4 !== r.length && 6 !== r.length)
          throw new Error('bbox must be an Array of 4 or 6 numbers');
        r.forEach(function(r) {
          if (!s(r)) throw new Error('bbox must only contain numbers');
        });
      }
      function h(r) {
        if (!r) throw new Error('id is required');
        if (-1 === ['string', 'number'].indexOf(typeof r))
          throw new Error('id must be a number or a string');
      }
      var c = t(2),
        l = t.n(c);
      var d = 6378137;
      function g(r) {
        var e = 0;
        if (r && r.length > 0) {
          e += Math.abs(m(r[0]));
          for (var t = 1; t < r.length; t++) e -= Math.abs(m(r[t]));
        }
        return e;
      }
      function m(r) {
        var e,
          t,
          n,
          o,
          i,
          a,
          s = 0,
          u = r.length;
        if (u > 2) {
          for (a = 0; a < u; a++)
            a === u - 2
              ? ((n = u - 2), (o = u - 1), (i = 0))
              : a === u - 1
                ? ((n = u - 1), (o = 0), (i = 1))
                : ((n = a), (o = a + 1), (i = a + 2)),
              (e = r[n]),
              (t = r[o]),
              (s += (p(r[i][0]) - p(e[0])) * Math.sin(p(t[1])));
          s = s * d * d / 2;
        }
        return s;
      }
      function p(r) {
        return r * Math.PI / 180;
      }
      var b = function(r) {
          return Object(n.e)(
            r,
            function(r, e) {
              return (
                r +
                (function r(e) {
                  var t,
                    n = 0;
                  switch (e.type) {
                    case 'Polygon':
                      return g(e.coordinates);
                    case 'MultiPolygon':
                      for (t = 0; t < e.coordinates.length; t++)
                        n += g(e.coordinates[t]);
                      return n;
                    case 'Point':
                    case 'MultiPoint':
                    case 'LineString':
                    case 'MultiLineString':
                      return 0;
                    case 'GeometryCollection':
                      for (t = 0; t < e.geometries.length; t++)
                        n += r(e.geometries[t]);
                      return n;
                  }
                })(e)
              );
            },
            0
          );
        },
        w = t(1),
        v = function(r, e, t) {
          if ('Polygon' !== r.geometry.type)
            throw new Error('The input feature must be a Polygon');
          void 0 === t && (t = 1);
          var n = r.geometry.coordinates,
            o = [],
            i = {};
          if (t) {
            for (var a = [], s = 0; s < n.length; s++)
              for (var u = 0; u < n[s].length - 1; u++) a.push(p(s, u));
            var f = l()();
            f.load(a);
          }
          for (var h = 0; h < n.length; h++)
            for (var c = 0; c < n[h].length - 1; c++) {
              if (t)
                f.search(p(h, c)).forEach(function(r) {
                  var e = r.ring,
                    t = r.edge;
                  m(h, c, e, t);
                });
              else
                for (var d = 0; d < n.length; d++)
                  for (var g = 0; g < n[d].length - 1; g++) m(h, c, d, g);
            }
          return (
            e ||
              (o = {
                type: 'Feature',
                geometry: { type: 'MultiPoint', coordinates: o },
              }),
            o
          );
          function m(r, t, a, s) {
            var u,
              f,
              h = n[r][t],
              c = n[r][t + 1],
              l = n[a][s],
              d = n[a][s + 1],
              g = (function(r, e, t, n) {
                if (y(r, t) || y(r, n) || y(e, t) || y(n, t)) return null;
                var o = r[0],
                  i = r[1],
                  a = e[0],
                  s = e[1],
                  u = t[0],
                  f = t[1],
                  h = n[0],
                  c = n[1],
                  l = (o - a) * (f - c) - (i - s) * (u - h);
                return 0 === l
                  ? null
                  : [
                      ((o * s - i * a) * (u - h) - (o - a) * (u * c - f * h)) /
                        l,
                      ((o * s - i * a) * (f - c) - (i - s) * (u * c - f * h)) /
                        l,
                    ];
              })(h, c, l, d);
            if (
              null !== g &&
              ((u =
                c[0] !== h[0]
                  ? (g[0] - h[0]) / (c[0] - h[0])
                  : (g[1] - h[1]) / (c[1] - h[1])),
              (f =
                d[0] !== l[0]
                  ? (g[0] - l[0]) / (d[0] - l[0])
                  : (g[1] - l[1]) / (d[1] - l[1])),
              !(u >= 1 || u <= 0 || f >= 1 || f <= 0))
            ) {
              var m = g,
                p = !i[m];
              p && (i[m] = !0),
                e ? o.push(e(g, r, t, h, c, u, a, s, l, d, f, p)) : o.push(g);
            }
          }
          function p(r, e) {
            var t,
              o,
              i,
              a,
              s = n[r][e],
              u = n[r][e + 1];
            return (
              s[0] < u[0] ? ((t = s[0]), (o = u[0])) : ((t = u[0]), (o = s[0])),
              s[1] < u[1] ? ((i = s[1]), (a = u[1])) : ((i = u[1]), (a = s[1])),
              { minX: t, minY: i, maxX: o, maxY: a, ring: r, edge: e }
            );
          }
        };
      function y(r, e) {
        if (!r || !e) return !1;
        if (r.length !== e.length) return !1;
        for (var t = 0, n = r.length; t < n; t++)
          if (r[t] instanceof Array && e[t] instanceof Array) {
            if (!y(r[t], e[t])) return !1;
          } else if (r[t] !== e[t]) return !1;
        return !0;
      }
      var x = function(r) {
          if ('Feature' != r.type)
            throw new Error('The input must a geojson object of type Feature');
          if (void 0 === r.geometry || null == r.geometry)
            throw new Error(
              'The input must a geojson object with a non-empty geometry'
            );
          if ('Polygon' != r.geometry.type)
            throw new Error('The input must be a geojson Polygon');
          for (
            var e = r.geometry.coordinates.length, t = [], n = 0;
            n < e;
            n++
          ) {
            var o = r.geometry.coordinates[n];
            _(o[0], o[o.length - 1]) || o.push(o[0]),
              t.push.apply(t, o.slice(0, o.length - 1));
          }
          if (
            !(function(r) {
              for (var e = {}, t = 1, n = 0, o = r.length; n < o; ++n) {
                if (e.hasOwnProperty(r[n])) {
                  t = 0;
                  break;
                }
                e[r[n]] = 1;
              }
              return t;
            })(t)
          )
            throw new Error(
              'The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)'
            );
          var s = t.length,
            u = v(r, function(r, e, t, n, o, i, a, s, u, f, h, c) {
              return [r, e, t, n, o, i, a, s, u, f, h, c];
            }),
            f = u.length;
          if (0 == f) {
            var h = [];
            for (n = 0; n < e; n++)
              h.push(
                i([r.geometry.coordinates[n]], {
                  parent: -1,
                  winding: P(r.geometry.coordinates[n]),
                })
              );
            var c = a(h);
            return U(), H(), c;
          }
          var d = [],
            g = [];
          for (n = 0; n < e; n++) {
            d.push([]);
            for (var m = 0; m < r.geometry.coordinates[n].length - 1; m++)
              d[n].push([
                new E(
                  r.geometry.coordinates[n][
                    (m + 1).modulo(r.geometry.coordinates[n].length - 1)
                  ],
                  1,
                  [n, m],
                  [n, (m + 1).modulo(r.geometry.coordinates[n].length - 1)],
                  void 0
                ),
              ]),
                g.push(
                  new A(
                    r.geometry.coordinates[n][m],
                    [n, (m - 1).modulo(r.geometry.coordinates[n].length - 1)],
                    [n, m],
                    void 0,
                    void 0,
                    !1,
                    !0
                  )
                );
          }
          for (n = 0; n < f; n++)
            d[u[n][1]][u[n][2]].push(
              new E(
                u[n][0],
                u[n][5],
                [u[n][1], u[n][2]],
                [u[n][6], u[n][7]],
                void 0
              )
            ),
              u[n][11] &&
                g.push(
                  new A(
                    u[n][0],
                    [u[n][1], u[n][2]],
                    [u[n][6], u[n][7]],
                    void 0,
                    void 0,
                    !0,
                    !0
                  )
                );
          var p = g.length;
          for (n = 0; n < d.length; n++)
            for (m = 0; m < d[n].length; m++)
              d[n][m].sort(function(r, e) {
                return r.param < e.param ? -1 : 1;
              });
          var y = [];
          for (n = 0; n < p; n++)
            y.push({
              minX: g[n].coord[0],
              minY: g[n].coord[1],
              maxX: g[n].coord[0],
              maxY: g[n].coord[1],
              index: n,
            });
          var x = l()();
          x.load(y);
          for (n = 0; n < d.length; n++)
            for (m = 0; m < d[n].length; m++)
              for (var Y = 0; Y < d[n][m].length; Y++) {
                R =
                  Y == d[n][m].length - 1
                    ? d[n][
                        (m + 1).modulo(r.geometry.coordinates[n].length - 1)
                      ][0].coord
                    : d[n][m][Y + 1].coord;
                var X = x.search({
                  minX: R[0],
                  minY: R[1],
                  maxX: R[0],
                  maxY: R[1],
                })[0];
                d[n][m][Y].nxtIsectAlongEdgeIn = X.index;
              }
          for (n = 0; n < d.length; n++)
            for (m = 0; m < d[n].length; m++)
              for (Y = 0; Y < d[n][m].length; Y++) {
                var R = d[n][m][Y].coord,
                  O = (X = x.search({
                    minX: R[0],
                    minY: R[1],
                    maxX: R[0],
                    maxY: R[1],
                  })[0]).index;
                O < s
                  ? (g[O].nxtIsectAlongRingAndEdge2 =
                      d[n][m][Y].nxtIsectAlongEdgeIn)
                  : _(g[O].ringAndEdge1, d[n][m][Y].ringAndEdgeIn)
                    ? (g[O].nxtIsectAlongRingAndEdge1 =
                        d[n][m][Y].nxtIsectAlongEdgeIn)
                    : (g[O].nxtIsectAlongRingAndEdge2 =
                        d[n][m][Y].nxtIsectAlongEdgeIn);
              }
          var j = [];
          for (n = 0, m = 0; m < e; m++) {
            var B = n;
            for (Y = 0; Y < r.geometry.coordinates[m].length - 1; Y++)
              g[n].coord[0] < g[B].coord[0] && (B = n), n++;
            var I = g[B].nxtIsectAlongRingAndEdge2;
            for (Y = 0; Y < g.length; Y++)
              if (
                g[Y].nxtIsectAlongRingAndEdge1 == B ||
                g[Y].nxtIsectAlongRingAndEdge2 == B
              ) {
                var k = Y;
                break;
              }
            var F = M([g[k].coord, g[B].coord, g[I].coord], !0) ? 1 : -1;
            j.push({ isect: B, parent: -1, winding: F });
          }
          j.sort(function(r, e) {
            return g[r.isect].coord > g[e.isect].coord ? -1 : 1;
          });
          for (h = []; j.length > 0; ) {
            var S = j.pop(),
              q = S.isect,
              L = S.parent,
              T = S.winding,
              N = h.length,
              C = [g[q].coord],
              G = q;
            if (g[q].ringAndEdge1Walkable)
              var D = g[q].ringAndEdge1,
                W = g[q].nxtIsectAlongRingAndEdge1;
            else (D = g[q].ringAndEdge2), (W = g[q].nxtIsectAlongRingAndEdge2);
            for (; !_(g[q].coord, g[W].coord); ) {
              C.push(g[W].coord);
              var J = void 0;
              for (n = 0; n < j.length; n++)
                if (j[n].isect == W) {
                  J = n;
                  break;
                }
              if ((void 0 != J && j.splice(J, 1), _(D, g[W].ringAndEdge1))) {
                if (
                  ((D = g[W].ringAndEdge2),
                  (g[W].ringAndEdge2Walkable = !1),
                  g[W].ringAndEdge1Walkable)
                ) {
                  var z = { isect: W };
                  M(
                    [
                      g[G].coord,
                      g[W].coord,
                      g[g[W].nxtIsectAlongRingAndEdge2].coord,
                    ],
                    1 == T
                  )
                    ? ((z.parent = L), (z.winding = -T))
                    : ((z.parent = N), (z.winding = T)),
                    j.push(z);
                }
                (G = W), (W = g[W].nxtIsectAlongRingAndEdge2);
              } else {
                if (
                  ((D = g[W].ringAndEdge1),
                  (g[W].ringAndEdge1Walkable = !1),
                  g[W].ringAndEdge2Walkable)
                ) {
                  z = { isect: W };
                  M(
                    [
                      g[G].coord,
                      g[W].coord,
                      g[g[W].nxtIsectAlongRingAndEdge1].coord,
                    ],
                    1 == T
                  )
                    ? ((z.parent = L), (z.winding = -T))
                    : ((z.parent = N), (z.winding = T)),
                    j.push(z);
                }
                (G = W), (W = g[W].nxtIsectAlongRingAndEdge1);
              }
            }
            C.push(g[W].coord),
              h.push(
                i([C], { index: N, parent: L, winding: T, netWinding: void 0 })
              );
          }
          c = a(h);
          function U() {
            for (var r = [], e = 0; e < c.features.length; e++)
              -1 == c.features[e].properties.parent && r.push(e);
            if (r.length > 1)
              for (e = 0; e < r.length; e++) {
                for (var t = -1, n = 0; n < c.features.length; n++)
                  r[e] != n &&
                    Object(w.a)(
                      c.features[r[e]].geometry.coordinates[0][0],
                      c.features[n],
                      { ignoreBoundary: !0 }
                    ) &&
                    b(c.features[n]) < 1 / 0 &&
                    (t = n);
                c.features[r[e]].properties.parent = t;
              }
          }
          function H() {
            for (var r = 0; r < c.features.length; r++)
              if (-1 == c.features[r].properties.parent) {
                var e = c.features[r].properties.winding;
                (c.features[r].properties.netWinding = e), K(r, e);
              }
          }
          function K(r, e) {
            for (var t = 0; t < c.features.length; t++)
              if (c.features[t].properties.parent == r) {
                var n = e + c.features[t].properties.winding;
                (c.features[t].properties.netWinding = n), K(t, n);
              }
          }
          return U(), H(), c;
        },
        E = function(r, e, t, n, o) {
          (this.coord = r),
            (this.param = e),
            (this.ringAndEdgeIn = t),
            (this.ringAndEdgeOut = n),
            (this.nxtIsectAlongEdgeIn = o);
        },
        A = function(r, e, t, n, o, i, a) {
          (this.coord = r),
            (this.ringAndEdge1 = e),
            (this.ringAndEdge2 = t),
            (this.nxtIsectAlongRingAndEdge1 = n),
            (this.nxtIsectAlongRingAndEdge2 = o),
            (this.ringAndEdge1Walkable = i),
            (this.ringAndEdge2Walkable = a);
        };
      function M(r, e) {
        if ((void 0 === e && (e = !0), 3 != r.length))
          throw new Error(
            'This function requires an array of three points [x,y]'
          );
        return (
          (r[1][0] - r[0][0]) * (r[2][1] - r[0][1]) -
            (r[1][1] - r[0][1]) * (r[2][0] - r[0][0]) >=
            0 ==
          e
        );
      }
      function P(r) {
        for (var e = 0, t = 0; t < r.length - 1; t++)
          r[t][0] < r[e][0] && (e = t);
        if (
          M(
            [
              r[(e - 1).modulo(r.length - 1)],
              r[e],
              r[(e + 1).modulo(r.length - 1)],
            ],
            !0
          )
        )
          var n = 1;
        else n = -1;
        return n;
      }
      function _(r, e) {
        if (!r || !e) return !1;
        if (r.length != e.length) return !1;
        for (var t = 0, n = r.length; t < n; t++)
          if (r[t] instanceof Array && e[t] instanceof Array) {
            if (!_(r[t], e[t])) return !1;
          } else if (r[t] != e[t]) return !1;
        return !0;
      }
      Number.prototype.modulo = function(r) {
        return (this % r + r) % r;
      };
      e.default = function(r) {
        var e = [];
        return (
          Object(n.c)(r, function(r) {
            'Polygon' === r.geometry.type &&
              Object(n.b)(x(r), function(t) {
                e.push(i(t.geometry.coordinates, r.properties));
              });
          }),
          a(e)
        );
      };
    },
    function(r, e, t) {
      'use strict';
      function n(r, e, t) {
        void 0 === t && (t = {});
        var n = { type: 'Feature' };
        return (
          (0 === t.id || t.id) && (n.id = t.id),
          t.bbox && (n.bbox = t.bbox),
          (n.properties = e || {}),
          (n.geometry = r),
          n
        );
      }
      function o(r, e, t) {
        return (
          void 0 === t && (t = {}), n({ type: 'Point', coordinates: r }, e, t)
        );
      }
      function i(r, e, t) {
        void 0 === t && (t = {});
        for (var o = 0, i = r; o < i.length; o++) {
          var a = i[o];
          if (a.length < 4)
            throw new Error(
              'Each LinearRing of a Polygon must have 4 or more Positions.'
            );
          for (var s = 0; s < a[a.length - 1].length; s++)
            if (a[a.length - 1][s] !== a[0][s])
              throw new Error('First and last Position are not equivalent.');
        }
        return n({ type: 'Polygon', coordinates: r }, e, t);
      }
      function a(r, e, t) {
        if ((void 0 === t && (t = {}), r.length < 2))
          throw new Error(
            'coordinates must be an array of two or more positions'
          );
        return n({ type: 'LineString', coordinates: r }, e, t);
      }
      function s(r, e) {
        void 0 === e && (e = {});
        var t = { type: 'FeatureCollection' };
        return (
          e.id && (t.id = e.id),
          e.bbox && (t.bbox = e.bbox),
          (t.features = r),
          t
        );
      }
      function u(r, e, t) {
        return (
          void 0 === t && (t = {}),
          n({ type: 'MultiLineString', coordinates: r }, e, t)
        );
      }
      function f(r, e, t) {
        return (
          void 0 === t && (t = {}),
          n({ type: 'MultiPoint', coordinates: r }, e, t)
        );
      }
      function h(r, e, t) {
        return (
          void 0 === t && (t = {}),
          n({ type: 'MultiPolygon', coordinates: r }, e, t)
        );
      }
      function c(r, t) {
        void 0 === t && (t = 'kilometers');
        var n = e.factors[t];
        if (!n) throw new Error(t + ' units is invalid');
        return r * n;
      }
      function l(r, t) {
        void 0 === t && (t = 'kilometers');
        var n = e.factors[t];
        if (!n) throw new Error(t + ' units is invalid');
        return r / n;
      }
      function d(r) {
        return 180 * (r % (2 * Math.PI)) / Math.PI;
      }
      function g(r) {
        return !isNaN(r) && null !== r && !Array.isArray(r);
      }
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.earthRadius = 6371008.8),
        (e.factors = {
          centimeters: 100 * e.earthRadius,
          centimetres: 100 * e.earthRadius,
          degrees: e.earthRadius / 111325,
          feet: 3.28084 * e.earthRadius,
          inches: 39.37 * e.earthRadius,
          kilometers: e.earthRadius / 1e3,
          kilometres: e.earthRadius / 1e3,
          meters: e.earthRadius,
          metres: e.earthRadius,
          miles: e.earthRadius / 1609.344,
          millimeters: 1e3 * e.earthRadius,
          millimetres: 1e3 * e.earthRadius,
          nauticalmiles: e.earthRadius / 1852,
          radians: 1,
          yards: e.earthRadius / 1.0936,
        }),
        (e.unitsFactors = {
          centimeters: 100,
          centimetres: 100,
          degrees: 1 / 111325,
          feet: 3.28084,
          inches: 39.37,
          kilometers: 0.001,
          kilometres: 0.001,
          meters: 1,
          metres: 1,
          miles: 1 / 1609.344,
          millimeters: 1e3,
          millimetres: 1e3,
          nauticalmiles: 1 / 1852,
          radians: 1 / e.earthRadius,
          yards: 1 / 1.0936,
        }),
        (e.areaFactors = {
          acres: 247105e-9,
          centimeters: 1e4,
          centimetres: 1e4,
          feet: 10.763910417,
          inches: 1550.003100006,
          kilometers: 1e-6,
          kilometres: 1e-6,
          meters: 1,
          metres: 1,
          miles: 3.86e-7,
          millimeters: 1e6,
          millimetres: 1e6,
          yards: 1.195990046,
        }),
        (e.feature = n),
        (e.geometry = function(r, e, t) {
          switch ((void 0 === t && (t = {}), r)) {
            case 'Point':
              return o(e).geometry;
            case 'LineString':
              return a(e).geometry;
            case 'Polygon':
              return i(e).geometry;
            case 'MultiPoint':
              return f(e).geometry;
            case 'MultiLineString':
              return u(e).geometry;
            case 'MultiPolygon':
              return h(e).geometry;
            default:
              throw new Error(r + ' is invalid');
          }
        }),
        (e.point = o),
        (e.points = function(r, e, t) {
          return (
            void 0 === t && (t = {}),
            s(
              r.map(function(r) {
                return o(r, e);
              }),
              t
            )
          );
        }),
        (e.polygon = i),
        (e.polygons = function(r, e, t) {
          return (
            void 0 === t && (t = {}),
            s(
              r.map(function(r) {
                return i(r, e);
              }),
              t
            )
          );
        }),
        (e.lineString = a),
        (e.lineStrings = function(r, e, t) {
          return (
            void 0 === t && (t = {}),
            s(
              r.map(function(r) {
                return a(r, e);
              }),
              t
            )
          );
        }),
        (e.featureCollection = s),
        (e.multiLineString = u),
        (e.multiPoint = f),
        (e.multiPolygon = h),
        (e.geometryCollection = function(r, e, t) {
          return (
            void 0 === t && (t = {}),
            n({ type: 'GeometryCollection', geometries: r }, e, t)
          );
        }),
        (e.round = function(r, e) {
          if ((void 0 === e && (e = 0), e && !(e >= 0)))
            throw new Error('precision must be a positive number');
          var t = Math.pow(10, e || 0);
          return Math.round(r * t) / t;
        }),
        (e.radiansToLength = c),
        (e.lengthToRadians = l),
        (e.lengthToDegrees = function(r, e) {
          return d(l(r, e));
        }),
        (e.bearingToAzimuth = function(r) {
          var e = r % 360;
          return e < 0 && (e += 360), e;
        }),
        (e.radiansToDegrees = d),
        (e.degreesToRadians = function(r) {
          return (r % 360) * Math.PI / 180;
        }),
        (e.convertLength = function(r, e, t) {
          if (
            (void 0 === e && (e = 'kilometers'),
            void 0 === t && (t = 'kilometers'),
            !(r >= 0))
          )
            throw new Error('length must be a positive number');
          return c(l(r, e), t);
        }),
        (e.convertArea = function(r, t, n) {
          if (
            (void 0 === t && (t = 'meters'),
            void 0 === n && (n = 'kilometers'),
            !(r >= 0))
          )
            throw new Error('area must be a positive number');
          var o = e.areaFactors[t];
          if (!o) throw new Error('invalid original units');
          var i = e.areaFactors[n];
          if (!i) throw new Error('invalid final units');
          return r / o * i;
        }),
        (e.isNumber = g),
        (e.isObject = function(r) {
          return !!r && r.constructor === Object;
        }),
        (e.validateBBox = function(r) {
          if (!r) throw new Error('bbox is required');
          if (!Array.isArray(r)) throw new Error('bbox must be an Array');
          if (4 !== r.length && 6 !== r.length)
            throw new Error('bbox must be an Array of 4 or 6 numbers');
          r.forEach(function(r) {
            if (!g(r)) throw new Error('bbox must only contain numbers');
          });
        }),
        (e.validateId = function(r) {
          if (!r) throw new Error('id is required');
          if (-1 === ['string', 'number'].indexOf(typeof r))
            throw new Error('id must be a number or a string');
        }),
        (e.radians2degrees = function() {
          throw new Error('method has been renamed to `radiansToDegrees`');
        }),
        (e.degrees2radians = function() {
          throw new Error('method has been renamed to `degreesToRadians`');
        }),
        (e.distanceToDegrees = function() {
          throw new Error('method has been renamed to `lengthToDegrees`');
        }),
        (e.distanceToRadians = function() {
          throw new Error('method has been renamed to `lengthToRadians`');
        }),
        (e.radiansToDistance = function() {
          throw new Error('method has been renamed to `radiansToLength`');
        }),
        (e.bearingToAngle = function() {
          throw new Error('method has been renamed to `bearingToAzimuth`');
        }),
        (e.convertDistance = function() {
          throw new Error('method has been renamed to `convertLength`');
        });
    },
    function(r, e, t) {
      'use strict';
      t.r(e);
      var n = t(0);
      e.default = function(r) {
        var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        return (
          Object(n.a)(r, function(r) {
            e[0] > r[0] && (e[0] = r[0]),
              e[1] > r[1] && (e[1] = r[1]),
              e[2] < r[0] && (e[2] = r[0]),
              e[3] < r[1] && (e[3] = r[1]);
          }),
          e
        );
      };
    },
    function(r, e, t) {
      'use strict';
      function n(r, e, t, n, a) {
        !(function r(e, t, n, i, a) {
          for (; i > n; ) {
            if (i - n > 600) {
              var s = i - n + 1,
                u = t - n + 1,
                f = Math.log(s),
                h = 0.5 * Math.exp(2 * f / 3),
                c =
                  0.5 *
                  Math.sqrt(f * h * (s - h) / s) *
                  (u - s / 2 < 0 ? -1 : 1),
                l = Math.max(n, Math.floor(t - u * h / s + c)),
                d = Math.min(i, Math.floor(t + (s - u) * h / s + c));
              r(e, t, l, d, a);
            }
            var g = e[t],
              m = n,
              p = i;
            for (o(e, n, t), a(e[i], g) > 0 && o(e, n, i); m < p; ) {
              for (o(e, m, p), m++, p--; a(e[m], g) < 0; ) m++;
              for (; a(e[p], g) > 0; ) p--;
            }
            0 === a(e[n], g) ? o(e, n, p) : o(e, ++p, i),
              p <= t && (n = p + 1),
              t <= p && (i = p - 1);
          }
        })(r, e, t || 0, n || r.length - 1, a || i);
      }
      function o(r, e, t) {
        var n = r[e];
        (r[e] = r[t]), (r[t] = n);
      }
      function i(r, e) {
        return r < e ? -1 : r > e ? 1 : 0;
      }
      (r.exports = n), (r.exports.default = n);
    },
    function(r, e, t) {
      const n = t(5),
        o = t(3),
        i = t(7),
        a = t(4),
        s = t(6);
      r.exports = (r, e) => {
        let t,
          u = e;
        return (
          void 0 === u && (u = {}),
          (t =
            void 0 !== u.features
              ? ((r, e) => {
                  const t = n(e),
                    u = r || 10,
                    f = [],
                    h = i(e);
                  let c = u,
                    l = !1,
                    d = 0;
                  for (; !l; ) {
                    const r = o.randomPoint(c, { bbox: h });
                    d += 1;
                    const e = a(r, t);
                    for (let r = 0; r < e.features.length; r += 1)
                      f.push(e.features[r]);
                    if (
                      (f.length < u ? (c = u - f.length) : (l = !0),
                      d > 100 * u)
                    )
                      throw new Error(
                        'Your are not lucky. Ending without reaching expected number of Points with input polygon(s)'
                      );
                  }
                  return s.featureCollection(f);
                })(r, u.features)
              : ((r, e) => {
                  const t = r || 10;
                  return o.randomPoint(t, { bbox: e });
                })(r, u.bbox))
        );
      };
    },
    function(r, e, t) {
      const n = t(9);
      r.exports = { random: n };
    },
  ]);
});
//# sourceMappingURL=random-points.min.js.map
